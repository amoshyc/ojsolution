########################################
[cfedu7] D. Optimal Number Permutation
########################################

.. sidebar:: Tags

    - ``tag_constructive_algorithm``

.. contents:: TOC
    :depth: 2


******************************************************
`題目 <http://codeforces.com/contest/622/problem/D>`_
******************************************************

給定常數 n，建構一個長度為 2n 的陣列，
其中 1 ~ n 每個數字各出現二次（分別位於 y[i], x[i], y[i] > x[i]），
並同時最小化 s = sum([(n - i) * abs(d[i] + i - n)] for 1 <= n <= n),
d[i] = y[i] - x[i]

************************
Specification
************************

::

    1 <= n <= 500000


************************
分析
************************

.. note:: 建構式演算法，並奇偶分開討論

觀察式子可知當::

    y[i] = x[i] + (n - i)

時，s 會是最小的，即等於 0。這代表了數字 i 需要 n - i 的距離差。

::

    n = 4
    i = 1 -> d[i] = 3
    i = 2 -> d[i] = 2
    i = 3 -> d[i] = 1
    i = 4 -> d[i] = 0

從上表可知，i = n 時，不可能達到，不過此時 (n - i) * abs(d[i] + i - n) 也會是 0，
所以事實上 i = n 這兩個數字填哪裡都可以，先不用考慮它。

接著我們看 i = 1 ~ n-1，發現距離差是不斷的 -1。直覺的想到，
我們可以將數字依序填入陣列，但這種方法需要的距離差是要不斷的 -2。像是這樣::

    n = 4
    1 2 3 4 4 3 2 1
    d[1] = 7
    d[2] = 5
    d[3] = 3
    d[4] = 1

而且數字是從 2 * n - 1 開始往下數，而不是我們想要的 n - 1。
對此，一個簡單的想法就是 **將陣列拆半**，一半填奇數數字，一半填偶數數字，
y[i] = x[i] + (n - i)::

    n = 3
    [1 _ 1] [2 2 _]

    n = 4
    [1 3 3 1] [2 _ 2 _]

    n = 5
    [1 3 _ 3 1] [2 4 4 2 _]

    n = 6
    [1 3 5 5 3 1] [2 4 _ 4 2 _]

    n = 7
    [1 3 5 _ 5 3 1] [2 4 6 6 4 2 _]

剩下的那兩個空位都拿來填 n，剛剛好！

i = 1 ~ n-1 每個數字 abs(d[i] - i + n) 都是 0。i = n 直接產生 0，
所以用這種方法建構出的陣列，s 必為 0。

::

    n = 3
    [1 3 1] [2 2 3]

    n = 4
    [1 3 3 1] [2 4 2 4]

    n = 5
    [1 3 5 3 1] [2 4 4 2 5]

    n = 6
    [1 3 5 5 3 1] [2 4 6 4 2 6]

    n = 7
    [1 3 5 7 5 3 1] [2 4 6 6 4 2 7]

************************
AC Code
************************

.. code-block:: cpp
    :linenos:

    #include <bits/stdc++.h>
    using namespace std;

    const int max_n = 500000;

    int n;
    int a[2 * max_n + 1];

    int main() {
        scanf("%d", &n);

        int idx = 1;
        for (int i = 1; i < n; i += 2) {
            a[idx] = a[idx + n - i] = i;
            idx++;
        }

        idx = n + 1;
        for (int i = 2; i < n; i += 2) {
            a[idx] = a[idx + n - i] = i;
            idx++;
        }

        for (int i = 1; i <= 2 * n; i++)
            if (a[i] == 0)
                a[i] = n;

        for (int i = 1; i <= 2 * n; i++)
            printf("%d ", a[i]);
        puts("");

        return 0;
    }
