###################################################
[cfedu9] C. The Smallest String Concatenation
###################################################

.. sidebar:: Tags

    - ``tag_sorting``
    - ``tag_greedy``

.. contents:: TOC
    :depth: 2


******************************************************
`題目 <http://codeforces.com/contest/632/problem/C>`_
******************************************************

給定 n 個字串 s[i], 欲將這 n 個字串串起來，請決定出一個順序，使串起來後的結果，是所有串法裡字典順序最小的。

************************
Specification
************************

::

    1 <= n <= 50000
    1 <= len(s[i]) <= 50
    1 <= sum(len(s[i])) <= 50000


************************
分析
************************

.. note:: Sorting 即可

直覺地可以想到，那就字典順序越小的字串就在越前面就好啦，但會發現這個策略在第二筆範測會出錯。
於是修改後，另一個策略是當字串 a 是字串 b 的前綴時，b 在前面，但仍存在測資使之出錯：

::

    jibw, ji, jp, bw, jizw

正確答案::

    bw, jibw, ji, jizw, jp

策略二的輸出::

    bw, jibw, jizw, ji, jp

那策略到底會什麼呢？答案是::

    當比較字串 a 與字串 b 時，如果 a.b < b.a 則 a 在前。

這樣為什麼正確呢，可以用反證法 [#f1]_。

----------------------------

若存在某個字串陣列::

    ..., s[k], s[k+1], ... (s[k].s[k+1] >= s[k+1].s[k])

則我們可以交換 s[k], s[k+1]::

    ..., s[k+1], s[k], ... (s[k+1].s[k] <= s[k].s[k+1])

這個字串的字典順序在會在前一個字串之前（或起碼相同，至少不會更差），顯而易見的。

我們也可以這麼想::

    排序時，現在相鄰的兩個字串 a, b，我不知道誰該在前面，誰在後面。
    那我就兩種方法都試試看，看哪一種方法的字典順序較小就用哪一種。
    所以就是比較 a.b 與 b.a 誰的字典順序較小。

策略清楚後，程式碼就簡單啦，排個序而已。C++11 的 lambda 真是方便！

.. [#f1] 因為只用到排序，排序的意思後排完序後，任相鄰兩項都滿足比較函式的性質，所以反證時，我們只需考慮某個相鄰兩項不滿足該性質。


************************
AC Code
************************

.. code-block:: cpp
    :linenos:

    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0);

        int N; cin >> N;
        vector<string> v(N, "");
        for (int i = 0; i < N; i++) {
            cin >> v[i];
        }

        sort(v.begin(), v.end(), [](const string& a, const string& b) {
            return (a + b < b + a);
        });

        for (auto s : v)
            cout << s;
        cout << endl;

        return 0;
    }
