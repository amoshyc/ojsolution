#####################################
[cf353] C. Money Transfers
#####################################

.. sidebar:: Tags

    - ``tag_greedy``
    - ``tag_map``

.. contents:: TOC
    :depth: 2

******************************************************
`題目 <http://codeforces.com/contest/675/problem/C>`_
******************************************************

N 個節點圍成一圈，每有節點有數字 a[i]，數字有正有負。保證總和為零。
定義一次操作為將某個節點的一些數字移到相鄰節點。
請問最少需要幾次操作，使得每個節點的數字皆為零。

************************
Specification
************************

::

    1 <= N <= 10^5
    -10^9 <= a[i] <= 10^9

************************
分析
************************

.. note:: 利用「總和為零的區間」

既然保證總和為零，那序列可以拆成一個或多個「總和為零的區間」。

長度為 l 、總和為零的區間有個性質::

    只需要 l - 1 次操作即可使區間內容每個節點都為 0

這是顯然易見的，設區間為 b[0], b[1], ..., b[l]，我可以::

    把 b[0] 的全部數字移到 b[1]
    把 b[1] 的全部數字移到 b[2]
    ...
    把 b[l - 1] 的全部數字移到 b[l] （此時 b[l] = 0）

將所有「總和為零的區間」的操作次數全部加總，我們可以得到::

    ans = N - K (K 是「總和為零的區間」的個數)

這樣題目所求就 reduce 成要最大化 K。

一個可行但不有效的 O(N^2) 方法::

    枚舉 a[i] 做為起點，計算 a[i] 的所有前綴和中有幾個 0。最大值即為答案。

這是可行的是因為，若 a[i] 被拆成 K 個「總和為零的區間」，任意連續的區間總和也會是零。

但 O(N^2) 顯然不是我們想要的。優化方法依賴以下性質::

    對所有「總和為零的區間」 a[j], a[j + 1], ...,a[k]，從序列第 0 項開始，
    到達該區間結束的前綴和 a[0] + a[1] + ... + a[s[j] - 1] 會是相同值。

所以我們可以設定出一個 greedy 的算法::

    從 a[0] 開始的所有前綴和中，哪個數字出現最多次，
    該數字的出現次數即為最大的 K。

這個算法可以在利用 map 或對前綴和排序 + 爬行法，在 O(N * lg(N)) 時間實作。

************************
AC Code
************************

.. code-block:: cpp
    :linenos:

    #include <bits/stdc++.h>
    using namespace std;

    typedef long long ll;

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0);

        ll N; cin >> N;
        vector<int> data(N, 0);
        for (int i = 0; i < N; i++) {
            cin >> data[i];
        }

        map<ll, int> cnt;
        ll sum = 0;
        ll ans = N - 1;
        for (int v : data) {
            sum += v;
            cnt[sum]++;
            ans = min(ans, N - cnt[sum]);
        }

        cout << ans << "\n";

        return 0;
    }
