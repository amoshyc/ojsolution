############################
二分搜
############################

.. sidebar:: Tags

    - ``tag_tutorial``
    - ``tag_binary_search``

.. contents:: TOC
    :depth: 3

**************************
敘述
**************************


只要存在某個連續的空間 S，
與判斷函式 bool C(...)（回傳 0(false) 或 1(true)）在此空間中的分布為：

::

    0 ... 0 0 0 1 1 1 1 ... 1

或

::

    1 ... 1 1 1 1 0 0 0 ... 0

這種單調的形式，即可使用二分搜在 O(lg(``|S|``)) 的時間求出 0 與 1 的分隔位置。
這時視題目題意，有時是要求分隔點的 0，有時是 1。

======================================
分布為 0 ... 0 0 0 1 1 1 1 ... 1
======================================

::

    以分布為 0 ... 0 0 0 1 1 1 1 ... 1 為例
    假設 S = [a, b]，我們想找出分隔點的所在。
    我們設下界 lb = a, 上界 ub = b，
    此時 C(lb) = 0, C(ub) = 1，且在算法中的任何時候，此式恆成立。
    演算法結束後，我們想讓：
    lb 停在分隔點的 0 上，即左邊數來最後一個 0 上面，
    ub 停在分隔點的 1 上，即左邊數來第一個 1 上面。

    於是我們不斷中找 lb 與 ub 的中點 mid = (lb + ub) / 2
    如果 C(mid) = 1，則分隔點在 mid 的左方，所以將 ub 移至 mid。
    如果 C(mid) = 0，則分隔點在 mid 的右方，所以將 lb 移至 mid。
    我們重覆以上動作直接 lb, ub 變成相鄰點為止

======== ====== ====== ====== ====== ====== ====== ======
index:   0      1      2      3      4      5      6
======== ====== ====== ====== ====== ====== ====== ======
C(index) 0      0      0      0      1      1      1
lb/ub:   lb                   mid                  ub
======== ====== ====== ====== ====== ====== ====== ======


======== ====== ====== ====== ====== ====== ====== ======
index:   0      1      2      3      4      5      6
======== ====== ====== ====== ====== ====== ====== ======
C(index) 0      0      0      0      1      1      1
lb/ub:                        lb     mid           ub
======== ====== ====== ====== ====== ====== ====== ======


======== ====== ====== ====== ====== ====== ====== ======
index:   0      1      2      3      4      5      6
======== ====== ====== ====== ====== ====== ====== ======
C(index) 0      0      0      0      1      1      1
lb/ub:                        lb     ub
======== ====== ====== ====== ====== ====== ====== ======

程式終止。

======================================
分布為 1 ... 1 1 1 1 0 0 0 ... 0
======================================

::

    以分布為 1 ... 1 1 1 1 0 0 0 ... 0 為例
    假設 S = [a, b]，我們想找出分隔點的所在。
    我們設下界 lb = a, 上界 ub = b，
    此時 C(lb) = 1, C(ub) = 0，且在算法中的任何時候，此式恆成立。
    演算法結束後，我們想讓：
    lb 停在分隔點的 1 上，即左邊數來最後一個 1 上面，
    ub 停在分隔點的 0 上，即左邊數來第一個 0 上面。

    於是我們不斷中找 lb 與 ub 的中點 mid = (lb + ub) / 2
    如果 C(mid) = 1，則分隔點在 mid 的左方，所以將 lb 移至 mid。
    如果 C(mid) = 0，則分隔點在 mid 的右方，所以將 ub 移至 mid。
    我們重覆以上動作直接 lb, ub 變成相鄰點為止

======== ====== ====== ====== ====== ====== ====== ======
index:   0      1      2      3      4      5      6
======== ====== ====== ====== ====== ====== ====== ======
C(index) 1      1      1      1      1      0      0
lb/ub:   lb                   mid                  ub
======== ====== ====== ====== ====== ====== ====== ======


======== ====== ====== ====== ====== ====== ====== ======
index:   0      1      2      3      4      5      6
======== ====== ====== ====== ====== ====== ====== ======
C(index) 1      1      1      1      1      0      0
lb/ub:                        lb     mid           ub
======== ====== ====== ====== ====== ====== ====== ======


======== ====== ====== ====== ====== ====== ====== ======
index:   0      1      2      3      4      5      6
======== ====== ====== ====== ====== ====== ====== ======
C(index) 1      1      1      1      1      0      0
lb/ub:                               lb     mid    ub
======== ====== ====== ====== ====== ====== ====== ======


======== ====== ====== ====== ====== ====== ====== ======
index:   0      1      2      3      4      5      6
======== ====== ====== ====== ====== ====== ====== ======
C(index) 1      1      1      1      1      0      0
lb/ub:                               lb     ub
======== ====== ====== ====== ====== ====== ====== ======

程式終止。

=========================
特殊情形
=========================

在一些情況中，C() 在 S 上的分布可能全為 0 或全為 1：

::

    0 0 ... 0
    1 1 ... 1

這兩種情況我們都可以直接在二分搜前預判掉，即::

    （以正常分佈為 0 ... 0 0 0 1 1 1 1 ... 1 為例）
    如果是 C(lb) = 1，那就是全為 1 的情形
    如果是 C(ub) = 0，那就是全為 0 的情形

或者我們就可以藉由調整解的空間來做同樣事情，只要將::

    （以正常分佈為 0 ... 0 0 0 1 1 1 1 ... 1 為例）
    下界設為 a - 1，則二分搜結束時，若分布全為 1，則 ub 停在 a 上
    上界設為 b + 1，則二分搜結束時，若分布全為 0，則 lb 停在 b 上
    
    或者
    
    下界設得足夠小且 C(lb) = 0
    上界設得足夠大且 C(ub) = 1

--------------------------------------------------


**************************
模板
**************************

針對 0 ... 0 0 0 1 1 1 1 ... 1 分布的二分搜：

.. code-block:: cpp
    :linenos:

    // 解的空間 S = [a, b]
    // 0 ... 0 0 0 1 1 1 1 ... 1
    // 有解的情況下，C(lb) = 0, C(ub) = 1 恆成立

    // 預判特殊情形，或不預判，但得將
    // 下界設為 a - 1，則二分搜結束時，若分布全為 1，則 ub 停在 a 上
    // 上界設為 b + 1，則二分搜結束時，若分布全為 0，則 lb 停在 b 上
    // 或者
    // 下界設得足夠小且 C(lb) = 0
    // 上界設得足夠大且 C(ub) = 1
    if (C(lb) == 1 || C(ub) == 0) 
        puts("...");

    int lb = a, ub = b;
    while (ub - lb > 1) {
        int mid = (lb + ub) / 2
        if (C(mid)) ub = mid;
        else lb = mid;
    }

    // lb 即為最後一個 0 的所在
    // ub 即為第一個 1 的所在


針對 1 ... 1 1 1 1 0 0 0 ... 0 的：

.. code-block:: cpp
    :linenos:

    // 解的空間 S = [a, b]
    // 1 ... 1 1 1 1 0 0 0 ... 0
    // 有解的情況下，C(lb) = 1, C(ub) = 0 恆成立

    // 預判特殊情形，或不預判，但得將
    // 下界設為 a - 1，則二分搜結束時，若分布全為 0，則 ub 停在 a 上
    // 上界設為 b + 1，則二分搜結束時，若分布全為 1，則 lb 停在 b 上
    // 或者
    // 下界設得足夠小且 C(lb) = 1
    // 上界設得足夠大且 C(ub) = 0
    if (C(lb) == 0 || C(ub) == 1)
        puts("...");

    int lb = a, ub = b;
    while (ub - lb > 1) {
        int mid = (lb + ub) / 2
        if (C(mid)) lb = mid;
        else ub = mid;
    }

    // lb 即為最後一個 1 的所在
    // ub 即為第一個 0 的所在


**************************
例題
**************************

待補
