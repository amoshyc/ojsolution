########################################
[cfother] B2. Permutations
########################################

.. sidebar:: Tags

    - ``tag_enum``
    - ``tag_greedy``
    - ``tag_constructive_algorithm``

.. contents:: TOC
    :depth: 2

******************************************************
`題目 <http://codeforces.com/contest/513/problem/B2>`_
******************************************************

對於所有 1~N 的排列 P，都定義一個 f 值為：
枚舉 P 的所有區間，加總每個區間的最小值。
給定 N 與 M，請問在那些擁有最大 f 值的 1~N 的排列中，字典順序第 M 小的是誰？

************************
Specification
************************

::

    1 <= N <= 50

************************
分析
************************

.. note:: 先找出怎麼建構出有最大 f 值的排列，再找第 M 個

這裡給出怎麼建構有最大 f 值的排列的算法，此算法可以保證找到所有符合該性質的排列::

    給定長度為 N 的空格子，
    從數字 1 開始，不斷地將數字寫入到最左邊或最右邊的空格子
    直到數字 N 被填入為止

（證明待補）

------------------

修改以上方法，可以在 O(N) 的時間求出字典順序第 K 小的，此方法是一個二分搜的概念。

假設所有有最大 f 值的排列（共有 2^(N-1) 個）已經都被找出來並排好序，而我們想找第 M 個：

.. image:: http://i.imgur.com/XnNf1HF.png

::

    1. 若 M <= 2^(N-2)，則從前面算法，我們知道這個排列最左邊那項會是 1，於是變成
        在這些最左邊為 1 的排列中，找第 M 個。

    2. 若 M > 2^(N-2)，同理我們可知，這個排列最右邊那項會是 1，於是變成
        在這些最右邊為 1 的排列中，找第 M - 2^(N-2) 個。

重覆這個過程，我們可以知道 2, 3, 4, ...各是在最左邊還是最右邊。

這有點類似在所有「有最大 f 值的那些排列」上二分搜，找第 M 小的在哪。


************************
AC Code
************************

.. code-block:: cpp
    :linenos:

    #include <bits/stdc++.h>
    using namespace std;

    typedef long long ll;

    int main() {
        int N; ll M;
        cin >> N >> M;

        int res[50];
        int s = 0, t = N - 1;
        int idx = 1;

        for (int len = N; len >= 1; len--) {
            ll cnt = (1ll << (len - 2));
            if (M <= cnt) {
                res[s++] = idx++;
            }
            else {
                res[t--] = idx++;
                M = M - cnt;
            }
        }

        for (int i = 0; i < N; i++)
            cout << res[i] << " ";
        cout << endl;

        return 0;
    }
